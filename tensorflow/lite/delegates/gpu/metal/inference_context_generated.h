// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INFERENCECONTEXT_TFLITE_GPU_METAL_DATA_H_
#define FLATBUFFERS_GENERATED_INFERENCECONTEXT_TFLITE_GPU_METAL_DATA_H_

#include "flatbuffers/flatbuffers.h"

#include "tensorflow/lite/delegates/gpu/common/gpu_model_generated.h"
#include "tensorflow/lite/delegates/gpu/common/task/serialization_base_generated.h"

namespace tflite {
namespace gpu {
namespace metal {
namespace data {

struct MetalProgram;
struct MetalProgramBuilder;

struct InferenceContext;
struct InferenceContextBuilder;

struct MetalProgram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetalProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFINE_NAMES = 4,
    VT_DEFINE_EXPRESSIONS = 6,
    VT_CODE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *define_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEFINE_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *define_expressions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEFINE_EXPRESSIONS);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEFINE_NAMES) &&
           verifier.VerifyVector(define_names()) &&
           verifier.VerifyVectorOfStrings(define_names()) &&
           VerifyOffset(verifier, VT_DEFINE_EXPRESSIONS) &&
           verifier.VerifyVector(define_expressions()) &&
           verifier.VerifyVectorOfStrings(define_expressions()) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           verifier.EndTable();
  }
};

struct MetalProgramBuilder {
  typedef MetalProgram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_define_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> define_names) {
    fbb_.AddOffset(MetalProgram::VT_DEFINE_NAMES, define_names);
  }
  void add_define_expressions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> define_expressions) {
    fbb_.AddOffset(MetalProgram::VT_DEFINE_EXPRESSIONS, define_expressions);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(MetalProgram::VT_CODE, code);
  }
  explicit MetalProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetalProgramBuilder &operator=(const MetalProgramBuilder &);
  flatbuffers::Offset<MetalProgram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetalProgram>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetalProgram> CreateMetalProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> define_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> define_expressions = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  MetalProgramBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_define_expressions(define_expressions);
  builder_.add_define_names(define_names);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetalProgram> CreateMetalProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *define_names = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *define_expressions = nullptr,
    const char *code = nullptr) {
  auto define_names__ = define_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*define_names) : 0;
  auto define_expressions__ = define_expressions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*define_expressions) : 0;
  auto code__ = code ? _fbb.CreateString(code) : 0;
  return tflite::gpu::metal::data::CreateMetalProgram(
      _fbb,
      define_names__,
      define_expressions__,
      code__);
}

struct InferenceContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InferenceContextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GPU_MODEL = 4,
    VT_TUNED_WORK_GROUP_SIZES_PER_NODE = 6,
    VT_METAL_PROGRAMS = 8
  };
  const tflite::gpu::data::GpuModel *gpu_model() const {
    return GetPointer<const tflite::gpu::data::GpuModel *>(VT_GPU_MODEL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *>(VT_TUNED_WORK_GROUP_SIZES_PER_NODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>> *metal_programs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>> *>(VT_METAL_PROGRAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GPU_MODEL) &&
           verifier.VerifyTable(gpu_model()) &&
           VerifyOffset(verifier, VT_TUNED_WORK_GROUP_SIZES_PER_NODE) &&
           verifier.VerifyVector(tuned_work_group_sizes_per_node()) &&
           verifier.VerifyVectorOfTables(tuned_work_group_sizes_per_node()) &&
           VerifyOffset(verifier, VT_METAL_PROGRAMS) &&
           verifier.VerifyVector(metal_programs()) &&
           verifier.VerifyVectorOfTables(metal_programs()) &&
           verifier.EndTable();
  }
};

struct InferenceContextBuilder {
  typedef InferenceContext Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gpu_model(flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model) {
    fbb_.AddOffset(InferenceContext::VT_GPU_MODEL, gpu_model);
  }
  void add_tuned_work_group_sizes_per_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node) {
    fbb_.AddOffset(InferenceContext::VT_TUNED_WORK_GROUP_SIZES_PER_NODE, tuned_work_group_sizes_per_node);
  }
  void add_metal_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>>> metal_programs) {
    fbb_.AddOffset(InferenceContext::VT_METAL_PROGRAMS, metal_programs);
  }
  explicit InferenceContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferenceContextBuilder &operator=(const InferenceContextBuilder &);
  flatbuffers::Offset<InferenceContext> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferenceContext>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferenceContext> CreateInferenceContext(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>>> metal_programs = 0) {
  InferenceContextBuilder builder_(_fbb);
  builder_.add_metal_programs(metal_programs);
  builder_.add_tuned_work_group_sizes_per_node(tuned_work_group_sizes_per_node);
  builder_.add_gpu_model(gpu_model);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferenceContext> CreateInferenceContextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,
    const std::vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node = nullptr,
    const std::vector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>> *metal_programs = nullptr) {
  auto tuned_work_group_sizes_per_node__ = tuned_work_group_sizes_per_node ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::Int3>>(*tuned_work_group_sizes_per_node) : 0;
  auto metal_programs__ = metal_programs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::metal::data::MetalProgram>>(*metal_programs) : 0;
  return tflite::gpu::metal::data::CreateInferenceContext(
      _fbb,
      gpu_model,
      tuned_work_group_sizes_per_node__,
      metal_programs__);
}

inline const tflite::gpu::metal::data::InferenceContext *GetInferenceContext(const void *buf) {
  return flatbuffers::GetRoot<tflite::gpu::metal::data::InferenceContext>(buf);
}

inline const tflite::gpu::metal::data::InferenceContext *GetSizePrefixedInferenceContext(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::gpu::metal::data::InferenceContext>(buf);
}

inline bool VerifyInferenceContextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::gpu::metal::data::InferenceContext>(nullptr);
}

inline bool VerifySizePrefixedInferenceContextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::gpu::metal::data::InferenceContext>(nullptr);
}

inline void FinishInferenceContextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::metal::data::InferenceContext> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedInferenceContextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::metal::data::InferenceContext> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace data
}  // namespace metal
}  // namespace gpu
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_INFERENCECONTEXT_TFLITE_GPU_METAL_DATA_H_
